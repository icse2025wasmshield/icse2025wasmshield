import matplotlib.pyplot as plt 
import matplotlib
plt.style.use('fivethirtyeight')
matplotlib.rcParams["figure.facecolor"] = 'white'
matplotlib.rcParams["axes.facecolor"] = 'white'

import os
from collections import defaultdict
import itertools
import random
import tqdm
import sklearn.ensemble
import sklearn.linear_model
import sklearn.svm
import numpy as np
import torch
import tqdm
from wasmshield.training.trainer import TrainableModel
import joblib
from sklearn.base import BaseEstimator
import wasmshield.utils
import wasmshield.preprocessing
import wasmshield.ennemies.minos
import wasmshield.ennemies.jabberwock
from sklearn.metrics import classification_report

import pandas as pd
import seaborn as sns
import random
import numpy as np
import wasmshield.utils
from umap.umap_ import UMAP


class MalwareEvaluator:
    def __init__(
        self,device,
    ):
        
        semantic_orig_dataset = 'datasets/wasim_dataset/WasmDataset/Cryptominer'
        files = list(os.walk(semantic_orig_dataset))[0][-1]
        files = [semantic_orig_dataset+'/'+file for file in files]

        self.malware_filenames_test = joblib.load('evaluation_logs/malware_filenames_test')
        self.malware_filenames_train = joblib.load('evaluation_logs/malware_filenames_train') + files
        malware_filenames_train = self.malware_filenames_train
        self.benign_filenames_train = joblib.load('evaluation_logs/benign_filenames_train')
        benign_filenames_train = self.benign_filenames_train
        self.benign_filenames_test = joblib.load('evaluation_logs/benign_filenames_test')


        self.malware_filenames_val_train = joblib.load('evaluation_logs/malware_filenames_val_train')
        self.malware_filenames_val_test = joblib.load('evaluation_logs/malware_filenames_val_test')
        self.benign_filenames_val_train = joblib.load('evaluation_logs/benign_filenames_val_train')
        self.benign_filenames_val_test = joblib.load('evaluation_logs/benign_filenames_val_test')

        # self.malware_images_test = joblib.load('malware_images_test')
        # malware_images_train = joblib.load('malware_images_train')
        # benign_images_train = joblib.load('benign_images_train')
        # self.benign_images_test = joblib.load('benign_images_test')

        self.results_benign = joblib.load('evaluation_logs/results_benign')
        self.results_malware = joblib.load('evaluation_logs/results_malware')

        self.results_benign_val = joblib.load('evaluation_logs/results_benign_val')
        self.results_malware_val = joblib.load('evaluation_logs/results_malware_val')

        self.device = device

        try: 
            self.y_train_val = joblib.load('evaluation_logs/malware_y_val_train_files_2')
            self.X_train_files_val = joblib.load('evaluation_logs/malware_X_val_train_files_2')
        except:

            benign_files_train = []
            res = wasmshield.utils.get_mutated_at_depth_modulo(
                self.benign_filenames_val_train,
                in_folder='datasets/malwareset/val_train_dataset/',
                depth=1,
                modulo=2,
                delete_past_files=True,
                inject_random_chars=True,
            )
            benign_files_train.extend(res[0])
            benign_files_train.extend(res[1])

            for _ in range(5):
                res = wasmshield.utils.get_mutated_at_depth_modulo(
                    self.benign_filenames_val_train,
                    in_folder='datasets/malwareset/val_train_dataset/',
                    depth=1,
                    modulo=2,
                    delete_past_files=False,
                    inject_random_chars=True,
                )
                benign_files_train.extend(res[1])

            malware_files_train = []
            res = wasmshield.utils.get_mutated_at_depth_modulo(
                self.malware_filenames_val_train,
                in_folder='datasets/malwareset/val_train_dataset_mal/',
                depth=1,
                modulo=2,
                delete_past_files=True,
                inject_random_chars=True,
            )
            malware_files_train.extend(res[0])
            malware_files_train.extend(res[1])

            nb_to_mutate = int((len(benign_files_train)-len(malware_files_train))//len(self.malware_filenames_val_train))-1
            for _ in range(nb_to_mutate):
                res = wasmshield.utils.get_mutated_at_depth_modulo(
                    self.malware_filenames_val_train,
                    in_folder='datasets/malwareset/val_train_dataset_mal/',
                    depth=1,
                    modulo=2,
                    delete_past_files=False,
                    inject_random_chars=True,
                )
                malware_files_train.extend(res[1])
            print(len(malware_files_train), len(benign_files_train))
            while len(malware_files_train)<len(benign_files_train):
                name = random.choice(self.malware_filenames_val_train)
                res = wasmshield.utils.get_mutated_at_depth_modulo(
                        [name],
                        in_folder='datasets/malwareset/val_train_dataset_mal/',
                        depth=1,
                        modulo=2,
                        delete_past_files=False,
                        inject_random_chars=True,
                )
                malware_files_train.append(res[1][0])

            self.y_train_val = [1]*len(malware_files_train) + [0]*len(benign_files_train)
            self.X_train_files_val = malware_files_train+benign_files_train

            joblib.dump(self.y_train_val, 'evaluation_logs/malware_y_val_train_files_2')
            joblib.dump(self.X_train_files_val, 'evaluation_logs/malware_X_val_train_files_2')

        try: 
            self.y_train = joblib.load('evaluation_logs/malware_y_train_files_2')
            self.X_train_files = joblib.load('evaluation_logs/malware_X_train_files_2')
        except:

            benign_files_train = []
            res = wasmshield.utils.get_mutated_at_depth_modulo(
                benign_filenames_train,
                in_folder='datasets/malwareset/train_dataset/',
                depth=1,
                modulo=2,
                delete_past_files=True,
                inject_random_chars=True,
            )
            benign_files_train.extend(res[0])
            benign_files_train.extend(res[1])

            for _ in range(3):
                res = wasmshield.utils.get_mutated_at_depth_modulo(
                    benign_filenames_train,
                    in_folder='datasets/malwareset/train_dataset/',
                    depth=1,
                    modulo=2,
                    delete_past_files=False,
                    inject_random_chars=True,
                )
                benign_files_train.extend(res[1])

            malware_files_train = []
            res = wasmshield.utils.get_mutated_at_depth_modulo(
                malware_filenames_train,
                in_folder='datasets/malwareset/train_dataset_mal/',
                depth=1,
                modulo=2,
                delete_past_files=True,
                inject_random_chars=True,
            )
            malware_files_train.extend(res[0])
            malware_files_train.extend(res[1])

            nb_to_mutate = int((len(benign_files_train)-len(malware_files_train))//len(malware_filenames_train))-1
            for _ in range(nb_to_mutate):
                res = wasmshield.utils.get_mutated_at_depth_modulo(
                    malware_filenames_train,
                    in_folder='datasets/malwareset/train_dataset_mal/',
                    depth=1,
                    modulo=2,
                    delete_past_files=False,
                    inject_random_chars=True,
                )
                malware_files_train.extend(res[1])
            print(len(malware_files_train), len(benign_files_train))
            while len(malware_files_train)<len(benign_files_train):
                name = random.choice(malware_filenames_train)
                res = wasmshield.utils.get_mutated_at_depth_modulo(
                        [name],
                        in_folder='datasets/malwareset/train_dataset_mal/',
                        depth=1,
                        modulo=2,
                        delete_past_files=False,
                        inject_random_chars=True,
                )
                malware_files_train.append(res[1][0])

            self.y_train = [1]*len(malware_files_train) + [0]*len(benign_files_train)
            self.X_train_files = malware_files_train+benign_files_train

            joblib.dump(self.y_train, 'evaluation_logs/malware_y_train_files_2')
            joblib.dump(self.X_train_files, 'evaluation_logs/malware_X_train_files_2')
        
        def zipper_for_eval(a:list,b:list):
            a,b = list(a), list(b)
            fill = a[-1] if (len(a) < len(b)) else b[-1]
            return list(itertools.zip_longest(a, b, fillvalue=fill))
        self.eval_pairs = zipper_for_eval(self.results_malware.keys(),self.results_benign.keys())

        try:
            self.minos_results = joblib.load('evaluation_logs/malware_minos_results')           
        except:
            self.minos_results = self.eval_malware_evolution(
                model_predict_func=wasmshield.ennemies.minos.minos_get_predictions, 
                model_names=['minos'],
            )
            joblib.dump(self.minos_results, 'evaluation_logs/malware_minos_results')
        
        try:
            self.jabberwock_results = joblib.load('evaluation_logs/malware_jabberwock_results')  
        except:
            
            print('Loading Vectors')
            jw_y_train = [1]*len(malware_filenames_train) + [0]*len(benign_filenames_train)
            jw_X_train = wasmshield.ennemies.jabberwock.get_vectors_jabberwock(malware_filenames_train+benign_filenames_train)

            jw_y_train=np.array(list(jw_y_train))
            jw_X_train=np.array(list(jw_X_train))
            p = np.arange(0, len(jw_X_train))
            np.random.shuffle(p)

            lr = sklearn.linear_model.LogisticRegression(class_weight='balanced', max_iter=1000, penalty='l1', solver='liblinear')
            lr.fit(jw_X_train[p], jw_y_train[p])

            svm = sklearn.svm.SVC(class_weight='balanced', max_iter=1000,)
            svm.fit(jw_X_train[p], jw_y_train[p])

            rf = sklearn.ensemble.RandomForestClassifier(class_weight='balanced', n_estimators=500)
            rf.fit(jw_X_train[p], jw_y_train[p])

            self.jabberwock_results = self.eval_malware_evolution(
                model_predict_func=self.jw_sklearn_predict_many_fun,
                sklearn_models=[lr,svm, rf], 
                model_names=[
                    'jabberwock_logistic_regression_l1',
                    'jabberwock_svm_rbf',
                    'jabberwock_rf_500',
                ],
            )

            joblib.dump(self.jabberwock_results, 'evaluation_logs/malware_jabberwock_results')  
        


    def get_vectors(self, files, model, preprocessor):
        # input = torch.tensor(np.array([x for x in images]), device=self.device, dtype=torch.float32).to(self.device)
        input = preprocessor(files).to(self.device)
        output = torch.nn.Flatten()(model.backbone(input)).cpu().numpy()
        return output
    
    def train_single_model(self, preprocessor, sklearn_model:BaseEstimator, trainable_model:TrainableModel, val=False):

        trainable_model.model = wasmshield.utils.set_torch_model_to_train(trainable_model.model, False)
        if val is False:
            X_train = np.array(self.get_vectors(self.X_train_files, trainable_model.model, preprocessor))
            y_train = np.array(self.y_train)
        else:
            X_train = np.array(self.get_vectors(self.X_train_files_val, trainable_model.model, preprocessor))
            y_train = np.array(self.y_train_val)
        
        p = np.arange(0, len(X_train))
        np.random.shuffle(p)
        X_train, y_train = X_train[p], y_train[p]

        sklearn_model.fit( X_train , y_train )

        return sklearn_model
    
    def train_many_models(self, preprocessor, sklearn_models:list[BaseEstimator], trainable_model:TrainableModel, val=False):

        trainable_model.model = wasmshield.utils.set_torch_model_to_train(trainable_model.model, False)
        if val is False:
            X_train = np.array(self.get_vectors(self.X_train_files, trainable_model.model, preprocessor))
            y_train = np.array(self.y_train)
        else:
            X_train = np.array(self.get_vectors(self.X_train_files_val, trainable_model.model, preprocessor))
            y_train = np.array(self.y_train_val)
        
        p = np.arange(0, len(X_train))
        np.random.shuffle(p)
        X_train, y_train = X_train[p], y_train[p]

        trained_sklearn_models = []
        for sklearn_model in sklearn_models:
            trained_sklearn_models.append(sklearn_model.fit( X_train , y_train ))
    
        return trained_sklearn_models
    
    def eval_many_models(self, sklearn_models, preprocessor, trainable_model:TrainableModel, sklearn_model_names,val=False):

        return self.eval_malware_evolution(
            model_predict_func=self.sklearn_predict_many_fun,
            sklearn_models=sklearn_models, 
            trainable_model=trainable_model,
            preprocessor=preprocessor,
            model_names=[
                trainable_model.name+f'+{sklearn_model_name}'
                for sklearn_model_name in sklearn_model_names
            ],
            val=val
        )
    
    def sklearn_predict_many_fun(self, files, preprocessor, sklearn_models, trainable_model,):
        X_test = self.get_vectors(files, trainable_model.model, preprocessor)
        for sklearn_model in sklearn_models:
            yield sklearn_model.predict(X_test)

    def jw_sklearn_predict_many_fun(self, files, sklearn_models):
        X_test = wasmshield.ennemies.jabberwock.get_vectors_jabberwock(files)
        for sklearn_model in sklearn_models:
            yield sklearn_model.predict(X_test)
    
    def eval_malware_evolution(self, model_predict_func, model_names, val=False, **kwargs):

        eval_dict = defaultdict(list)
        for mal_id, ben_id in tqdm.tqdm(self.eval_pairs):

            if val is False:
                ffm, ffb = self.results_malware[mal_id], self.results_benign[ben_id]
            else:
                ffm, ffb = self.results_malware_val[mal_id], self.results_benign_val[ben_id]
            y_test = [1 for _ in range(len(ffm))] + [0 for _ in range(len(ffb))] 
            y_preds = model_predict_func(ffm+ffb, **kwargs)
            for model_name, y_pred in zip(model_names, y_preds):
                r1 = classification_report(y_true=y_test, y_pred=y_pred, output_dict=True)
                eval_dict[model_name].append(r1)

        return eval_dict
    

    def malware_results_plotter(
        self, 
        model_results, 
        figsize, 
        figsize2, 
        rounder=0, 
        legend_bbox_to_anchor=(0.5, -0.1), 
        ncol_legend=2, 
        y_step=0.05,
        show_concurrent=True,
    ):

        def myround(x, base=5):
            return base * round(x/base)

        def rounding(x, round_to=5):
            return [myround(y, round_to) for y in x ]
        
        if show_concurrent:
            model_results['minos'] = self.minos_results['minos']
            model_results['jabberwock_svm_rbf'] = self.jabberwock_results['jabberwock_svm_rbf']
            model_results['jabberwock_rf_500'] = self.jabberwock_results['jabberwock_rf_500']
            model_results['jabberwock_logistic_regression_l1'] = self.jabberwock_results['jabberwock_logistic_regression_l1']

        # x = list(self.results_malware.keys())
        # x = [round(x,-rounder) for x in self.results_malware.keys()]
        x = [myround(x,rounder) for x in self.results_malware.keys()]
        y_getters = lambda k : [
            (lambda result_dicts : [x[k]['precision'] for x in result_dicts] ,'Precision'),
            (lambda result_dicts : [x[k]['recall'] for x in result_dicts], 'Rappel'),
            (lambda result_dicts : [x[k]['f1-score'] for x in result_dicts], 'F1-Score'),
        ]

        for k, y_label in [('weighted avg', 'Overall'), ('1', 'Classe de Malware'), ('0', 'Classe Benign')]:
            plt.figure(figsize=figsize, facecolor='white')
            for (model_name, result_dicts) in (model_results.items()):
                for y_idx, (y_getter, y_type) in enumerate(y_getters(k)):
                    plt.subplot(1,len(y_getters(k)),y_idx+1)
                    y = np.array(y_getter(result_dicts))
                    g = sns.lineplot(x=x, y=y, label=model_name, marker='o',)
                    g.set_ylim(0, 1.02)
                    g.set_ylabel(y_type+f' ( {y_label} ) ')
                    g.set_yticks(np.arange(0, 1.02, y_step))
                    g.set_xlabel('Profondeur de Mutation')  
                    plt.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor,
                        fancybox=True, shadow=True, ncol=ncol_legend)
        
        plt.figure(figsize=figsize2, facecolor='white')
        for (model_name, result_dicts) in (model_results.items()):
            for y_idx, (y_label, (y_getter, y_type)) in enumerate([
                ('Overall', y_getters('weighted avg')[2],),
                ('Classe de Malware', y_getters('1')[1],),
            ]):
                plt.subplot(1,2,y_idx+1)
                y = np.array(y_getter(result_dicts))
                g = sns.lineplot(x=x, y=y, label=model_name, marker='o',)
                g.set_ylim(0, 1.02)
                g.set_yticks(np.arange(0, 1.02, y_step))
                g.set_ylabel(y_type+f' ( {y_label} ) ')
                g.set_xlabel('Profondeur de Mutation')  
                plt.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor, fancybox=True, shadow=True, ncol=ncol_legend)

    def malware_results_barplotter(self, model_results, figsize1, figsize2, depths, plot_heatmaps=False, palette=None, legend_bbox_to_anchor=(0.5, -0.1), ncol_legend=2):

        recs = []

        models = list(model_results.keys())

        if plot_heatmaps:

            cols = ['Column {}'.format(col) for col in models]
            rows = [f'M{self.eval_pairs[n][0]}_B{self.eval_pairs[n][1]}' for n in depths]
            fig, axes = plt.subplots(nrows=len(depths), ncols=len(models), figsize=figsize1, facecolor='white')

            for ax, col in zip(axes[0], cols):
                ax.set_title(col)
            for ax, row in zip(axes[:,0], rows):
                ax.set_ylabel(row, rotation=0, size='large')

            fig.tight_layout()

        for depth_idx, n in enumerate(depths):
            m = self.eval_pairs[n]
            d_name = f'M{m[0]}_B{m[1]}'
            models = list(model_results.items())
            for model_idx, (model_name, res_dict) in enumerate(models):
                recs.append(
                    {
                        'model_name' : model_name,
                        'f1-score' : res_dict[n]['weighted avg']['f1-score'],
                        'd_name' : d_name
                    }
                )
                cf_matrix = np.array(
                    [[res_dict[n]['0']['precision'], 1-res_dict[n]['0']['precision']],
                    [1-res_dict[n]['1']['precision'], res_dict[n]['1']['precision']]]
                )
                # ax = plt.subplot(len(depths), len(models), depth_idx*(len(models))+model_idx+1)
                # plt.title(f'{model_name} {d_nam<e}')
                if plot_heatmaps:
                    sns.heatmap(cf_matrix, annot=True, fmt='.2%', cmap='Blues', ax=axes[depth_idx][model_idx])

        plt.figure(figsize=figsize2, facecolor='white')
        ax = sns.barplot(pd.DataFrame.from_records(recs), x='d_name', y='f1-score', hue='model_name', palette=palette)
        # sns.move_legend(ax, "upper left", bbox_to_anchor=(1, 1))
        ax.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor,
          fancybox=True, shadow=True, ncol=ncol_legend)
        for i in ax.containers:
            ax.bar_label(i,fmt='%.4f')
        
    def malware_results_embedding_plotter(
            self,
            vector_getter,
            figsize,
            n_m,
            n_b,
            preprocessor=None,
            vizzer = UMAP(),
            title="Plot of Mawlare-Benign",
            **kwargs,
        ):

        if model:=kwargs.get('model'):
            wasmshield.utils.set_torch_model_to_train(model, False)

        all_vectors_m = []
        for d, files in tqdm.tqdm(list(self.results_malware.items())):
            all_vectors_m.extend(
                vector_getter(
                    [preprocessor(f) for f in random.sample(files,n_m)]
                    if preprocessor is not None 
                    else random.sample(files,n_m),
                    **kwargs,
                )
            )

        all_vectors_b = []
        for d, files in tqdm.tqdm(list(self.results_benign.items())):
            all_vectors_b.extend(
                vector_getter(
                    [preprocessor(f) for f in random.sample(files,n_b)]
                    if preprocessor is not None 
                    else random.sample(files,n_b),**kwargs,
                )
            )

        y_viz = ['Malware' for _ in all_vectors_m]+['Benign' for _ in all_vectors_b]
        ts = vizzer.fit_transform(np.array(all_vectors_m+all_vectors_b))
        # ts = TSNE(perplexity=10).fit_transform(np.array(all_vectors_m+all_vectors_b), y_viz)
        df = pd.DataFrame()
        df["y"] = y_viz
        df["comp-1"] = ts[:,0]
        df["comp-2"] = ts[:,1]

        plt.figure(figsize=figsize, facecolor='white')

        # sns.set_style("dark")
        g = sns.scatterplot(x="comp-1", y="comp-2", hue=df.y.tolist(),
                        palette=["#de1a24","#056517",],
                        data=df)
        g.set(title=title) 
