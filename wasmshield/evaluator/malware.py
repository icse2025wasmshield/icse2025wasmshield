from time import perf_counter
import matplotlib.pyplot as plt 
import matplotlib

from wasmshield.models.base_handler import BaseHandler
plt.style.use('fivethirtyeight')
matplotlib.rcParams["figure.facecolor"] = 'white'
matplotlib.rcParams["axes.facecolor"] = 'white'

import os
from collections import defaultdict
import itertools
import random
import tqdm
import sklearn.ensemble
import sklearn.linear_model
import sklearn.svm
import numpy as np
import torch
import tqdm
from wasmshield.training.trainer import TrainableModel, divide_chunks
import joblib
from sklearn.base import BaseEstimator
import wasmshield.utils
import wasmshield.preprocessing
import wasmshield.ennemies.minos
import wasmshield.ennemies.jabberwock
from sklearn.metrics import classification_report

from wasmshield.models.base_classifier import BaseClassifier

import pandas as pd
import seaborn as sns
import random
import numpy as np
import wasmshield.utils
from umap.umap_ import UMAP


class MalwareEvaluator:
    def __init__(
        self,device,
    ):
        
        semantic_orig_dataset = 'datasets/wasim_dataset/WasmDataset/Cryptominer'
        files = list(os.walk(semantic_orig_dataset))[0][-1]
        files = [semantic_orig_dataset+'/'+file for file in files]

        #
        self.malware_filenames_test = joblib.load('evaluation_logs/malware_filenames_test')
        self.malware_filenames_train = joblib.load('evaluation_logs/malware_filenames_train') + files
        malware_filenames_train = self.malware_filenames_train
        self.benign_filenames_train = joblib.load('evaluation_logs/benign_filenames_train')
        benign_filenames_train = self.benign_filenames_train
        self.benign_filenames_test = joblib.load('evaluation_logs/benign_filenames_test')
        #
        self.y_train = joblib.load('evaluation_logs/malware_y_train_files_2')
        self.X_train_files = joblib.load('evaluation_logs/malware_X_train_files_2')
        #
        self.results_benign = joblib.load('evaluation_logs/results_benign')
        self.results_malware = joblib.load('evaluation_logs/results_malware')

        #
        self.malware_filenames_val_train = joblib.load('evaluation_logs/malware_filenames_val_train')
        self.malware_filenames_val_test = joblib.load('evaluation_logs/malware_filenames_val_test')
        self.benign_filenames_val_train = joblib.load('evaluation_logs/benign_filenames_val_train')
        self.benign_filenames_val_test = joblib.load('evaluation_logs/benign_filenames_val_test')
        #
        self.results_benign_val = joblib.load('evaluation_logs/results_benign_val')
        self.results_malware_val = joblib.load('evaluation_logs/results_malware_val')
        #
        self.y_train_val = joblib.load('evaluation_logs/malware_y_val_train_files_2')
        self.X_train_files_val = joblib.load('evaluation_logs/malware_X_val_train_files_2')

        self.device = device

        def zipper_for_eval(a:list,b:list):
            a,b = list(a), list(b)
            fill = a[-1] if (len(a) < len(b)) else b[-1]
            return list(itertools.zip_longest(a, b, fillvalue=fill))
        
        self.eval_pairs = zipper_for_eval(
            self.results_malware.keys(),
            self.results_benign.keys(),
        )

        self.llvm_base_path = "compiled_datasets/llvm_obf/authors"
    
        self.obfuscation_technique_mapper = {
            'bcfobf':"Bogus control flow",
            'cffobf':"Control flow flattening",
            'constenc':"Constants encryption",
            'funcwra':"Function wrapper",
            'indibran':"Indirect branches",
            'splitobf':"Basic block splitting",
            'strcry':"String encryption",
            'subobf':"Substitute instruction",
            'antialiasanalysis':"Anti-alias analysis", 
            'antitaintanalysis':"Anti-taint analysis", 
            'encodearithmetic':"Encode arithmetic", 
            'encodeliterals':"Encode literals", 
            'flatten':"Flattening", 
            'randomfuns':"Random functions", 
            'split':"Function splitting", 
            'virtualize':"Virtualization",
            'AddCustomSectionMutator':"Add custom section", 
            'AddFunctionMutator':"Add function", 
            "AddTypeMutator":"Add Type", 
            "CodemotionMutator":"Code motion", 
            "PeepholeMutator":"Peephole"
        }

        (
            self.obfuscated_X_test, 
            self.obfuscated_y_test, 
            self.obfuscated_name_test, 
            self.obfuscated_technique_test,
        ) = self.handle_obfuscated_files(
            obfuscated_benign_folders=[
                'lcs','needleman_wunsch','smith_waterman','seqtk','f1-race','pong','breakout','wgsim','wasm-asteroids','snake',
            ],
            obfuscated_malware_folders=[
                'cn-1', 'cn-2', 'cn-r', 'cn-half', 'cn-lite-1', 'cn-lite-2', 'cn-rwz', 'cn-pico-trtl',
            ],
            obfuscations=[
                ('wasm-mutate','-1', ['AddCustomSectionMutator', 'AddFunctionMutator', "AddTypeMutator", "CodemotionMutator", "PeepholeMutator"]),
                ('wasm-mutate','-2', [
                    f'iteration-{i}' 
                    for i in [100,200,300,400,500,600,700,800,900,1000]
                ]),
                ('tigress','', [
                    'encodearithmetic', 'randomfuns', 'split',
                    ]),
                ('llvm','',['bcfobf','cffobf','constenc','funcwra','indibran','splitobf','strcry','subobf']),
                ('unobfuscated','',['None']),
            ],
        )

        (
            self.obfuscated_X_train, 
            self.obfuscated_y_train, 
            self.obfuscated_name_train, 
            self.obfuscated_technique_train,
        ) = self.handle_obfuscated_files(
            obfuscated_benign_folders=[ 'tree', 'game-of-life', ],
            obfuscated_malware_folders=[ 'cn-0', 'cn-lite-0', ],
            obfuscations=[
                ('tigress','', ['antialiasanalysis', 'antitaintanalysis', 'encodeliterals', 'flatten', 'virtualize']),
                ('unobfuscated','',['None']),
                ('wasm-mutate','-1', ['AddCustomSectionMutator', 'AddFunctionMutator', "AddTypeMutator", "CodemotionMutator", "PeepholeMutator"]),
            ],
        )

        self.train_X = np.concatenate((
            np.array(self.X_train_files),
            np.array(self.obfuscated_X_train),
        ))
        self.train_y = np.concatenate((
            np.array(self.y_train),
            np.array(self.obfuscated_y_train),
        ))

        self.test_X = []
        self.test_y = []
        for mal_id, ben_id in (self.eval_pairs):
            ffm, ffb = self.results_malware[mal_id], self.results_benign[ben_id]
            y_test = [1 for _ in range(len(ffm))] + [0 for _ in range(len(ffb))] 
            self.test_X+=ffm+ffb
            self.test_y+=y_test
        self.test_X = np.array(self.test_X)
        self.test_y = np.array(self.test_y)

    def get_obfuscated_df(self, model_name):
        return pd.DataFrame.from_dict({
            'Obfuscation': self.obfuscated_name_test,
            'Transformation': self.obfuscated_technique_test,
            'label': self.obfuscated_y_test,
            'model_name':[
                model_name for _ 
                in range(len(self.obfuscated_y_test))
            ],
            'indexes':list(range(len(self.obfuscated_y_test)))
        })

    def handle_obfuscated_files(
        self,
        obfuscated_malware_folders,
        obfuscated_benign_folders,
        obfuscations,
    ):
        
        obfuscated_y = []
        obfuscated_X = []
        obfuscated_name = []
        obfuscated_technique = []

        for folders, y_value in [(obfuscated_malware_folders,1), (obfuscated_benign_folders,0)]:
            for folder in folders:
                for obfuscation_name, obfuscation_split, obfuscation_techniques in obfuscations:
                    for obfuscation_technique in obfuscation_techniques:

                        if obfuscation_technique != 'None':
                            file_path = f"{self.llvm_base_path}/{folder}/{obfuscation_name}/{obfuscation_technique}/{folder}.wasm"
                        else:
                            file_path = f"{self.llvm_base_path}/{folder}/{obfuscation_name}/{folder}.wasm"

                        if not os.path.exists(file_path):
                            print(file_path)

                        obfuscated_name.append(
                            obfuscation_name+obfuscation_split
                        )
                        obfuscated_technique.append(
                            self.obfuscation_technique_mapper.get(
                                obfuscation_technique, 
                                obfuscation_technique
                            )
                        )
                        obfuscated_X.append(file_path)
                        obfuscated_y.append(y_value)

        return obfuscated_X, obfuscated_y, obfuscated_name, obfuscated_technique
    
    def train_many_models(
        self, 
        classifier_models:list[BaseClassifier],
    ):
        p = perf_counter()
        X_train = np.array(self.train_X)
        y_train = np.array(self.train_y)
        p = perf_counter() - p

        times = []
        for model in classifier_models:
            time = model.train_classifier(X_train, y_train)
            times.append(time)
        return {
            'training_times':times,
        }
    
    def eval_malware_evolution(
        self, classifier_models:list[BaseClassifier],
    ):
        pred_times = []
        results_evolution_lists = []
        accuracies = []
        f1_scores = []
        overall_results_list = []

        for classifier_model in classifier_models:
            pred_time, y_pred = classifier_model.predict_from_files(
                files=self.test_X,
            )
            results_evolution_list = []
            for pred_evolution, y_evolution in zip(
                divide_chunks(y_pred, 48),
                divide_chunks(self.test_y, 48),
            ):
                results_evolution = classification_report(
                    y_evolution,
                    pred_evolution,
                    output_dict=True,
                )
                results_evolution_list.append(results_evolution)
            overall_results = classification_report(
                self.test_y, y_pred, output_dict=True
            )
            pred_times.append(pred_time)
            results_evolution_lists.append(results_evolution_list)
            accuracies.append(
                overall_results['accuracy']
            )
            f1_scores.append(
                overall_results['weighted avg']['f1-score']
            )
            overall_results_list.append(overall_results)

        return {
            'pred_times':pred_times,
            'results_evolution_lists':results_evolution_lists,
            'accuracies':accuracies,
            'f1_scores':f1_scores,
            'overall_results_list':overall_results_list,
        }
    
    def malware_results_plotter(
        self, 
        model_results, 
        figsize, 
        figsize2, 
        rounder=0, 
        legend_bbox_to_anchor=(0.5, -0.1), 
        ncol_legend=2, 
        y_step=0.05,
        show_concurrent=True,
    ):

        def myround(x, base=5):
            return base * round(x/base)
        
        if show_concurrent:
            model_results['minos'] = self.minos_results['minos']
            model_results['jabberwock_svm_rbf'] = self.jabberwock_results['jabberwock_svm_rbf']
            model_results['jabberwock_rf_500'] = self.jabberwock_results['jabberwock_rf_500']
            model_results['jabberwock_logistic_regression_l1'] = self.jabberwock_results['jabberwock_logistic_regression_l1']

        # x = list(self.results_malware.keys())
        # x = [round(x,-rounder) for x in self.results_malware.keys()]
        x = [myround(x,rounder) for x in self.results_malware.keys()]
        y_getters = lambda k : [
            (lambda result_dicts : [x[k]['precision'] for x in result_dicts] ,'Precision'),
            (lambda result_dicts : [x[k]['recall'] for x in result_dicts], 'Rappel'),
            (lambda result_dicts : [x[k]['f1-score'] for x in result_dicts], 'F1-Score'),
        ]
        
        for k, y_label in [('weighted avg', 'Overall'), ('1', 'Classe de Malware'), ('0', 'Classe Benign')]:
            plt.figure(figsize=figsize, facecolor='white')
            for (model_name, result_dicts) in (model_results.items()):
                for y_idx, (y_getter, y_type) in enumerate(y_getters(k)):
                    plt.subplot(1,len(y_getters(k)),y_idx+1)
                    y = np.array(y_getter(result_dicts))
                    g = sns.lineplot(x=x, y=y, label=model_name, marker='o',)
                    g.set_ylim(0, 1.02)
                    g.set_ylabel(y_type+f' ( {y_label} ) ')
                    g.set_yticks(np.arange(0, 1.02, y_step))
                    g.set_xlabel('Profondeur de Mutation')  
                    plt.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor,
                        fancybox=True, shadow=True, ncol=ncol_legend)
        
        plt.figure(figsize=figsize2, facecolor='white')
        for (model_name, result_dicts) in (model_results.items()):
            for y_idx, (y_label, (y_getter, y_type)) in enumerate([
                ('Overall', y_getters('weighted avg')[2],),
                ('Classe de Malware', y_getters('1')[1],),
            ]):
                plt.subplot(1,2,y_idx+1)
                y = np.array(y_getter(result_dicts))
                g = sns.lineplot(x=x, y=y, label=model_name, marker='o',)
                g.set_ylim(0, 1.02)
                g.set_yticks(np.arange(0, 1.02, y_step))
                g.set_ylabel(y_type+f' ( {y_label} ) ')
                g.set_xlabel('Profondeur de Mutation')  
                plt.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor, fancybox=True, shadow=True, ncol=ncol_legend)

    def malware_results_barplotter(self, model_results, figsize1, figsize2, depths, plot_heatmaps=False, palette=None, legend_bbox_to_anchor=(0.5, -0.1), ncol_legend=2):

        recs = []

        models = list(model_results.keys())

        if plot_heatmaps:

            cols = ['Column {}'.format(col) for col in models]
            rows = [f'M{self.eval_pairs[n][0]}_B{self.eval_pairs[n][1]}' for n in depths]
            fig, axes = plt.subplots(nrows=len(depths), ncols=len(models), figsize=figsize1, facecolor='white')

            for ax, col in zip(axes[0], cols):
                ax.set_title(col)
            for ax, row in zip(axes[:,0], rows):
                ax.set_ylabel(row, rotation=0, size='large')

            fig.tight_layout()

        for depth_idx, n in enumerate(depths):
            m = self.eval_pairs[n]
            d_name = f'M{m[0]}_B{m[1]}'
            models = list(model_results.items())
            for model_idx, (model_name, res_dict) in enumerate(models):
                recs.append(
                    {
                        'model_name' : model_name,
                        'f1-score' : res_dict[n]['weighted avg']['f1-score'],
                        'd_name' : d_name
                    }
                )
                cf_matrix = np.array(
                    [[res_dict[n]['0']['precision'], 1-res_dict[n]['0']['precision']],
                    [1-res_dict[n]['1']['precision'], res_dict[n]['1']['precision']]]
                )
                # ax = plt.subplot(len(depths), len(models), depth_idx*(len(models))+model_idx+1)
                # plt.title(f'{model_name} {d_nam<e}')
                if plot_heatmaps:
                    sns.heatmap(cf_matrix, annot=True, fmt='.2%', cmap='Blues', ax=axes[depth_idx][model_idx])

        plt.figure(figsize=figsize2, facecolor='white')
        ax = sns.barplot(pd.DataFrame.from_records(recs), x='d_name', y='f1-score', hue='model_name', palette=palette)
        # sns.move_legend(ax, "upper left", bbox_to_anchor=(1, 1))
        ax.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor,
          fancybox=True, shadow=True, ncol=ncol_legend)
        for i in ax.containers:
            ax.bar_label(i,fmt='%.4f')
        
    def malware_results_embedding_plotter(
            self,
            vector_getter,
            figsize,
            n_m,
            n_b,
            preprocessor=None,
            vizzer = UMAP(),
            title="Plot of Mawlare-Benign",
            **kwargs,
        ):

        if model:=kwargs.get('model'):
            wasmshield.utils.set_torch_model_to_train(model, False)

        all_vectors_m = []
        for d, files in tqdm.tqdm(list(self.results_malware.items())):
            all_vectors_m.extend(
                vector_getter(
                    [preprocessor(f) for f in random.sample(files,n_m)]
                    if preprocessor is not None 
                    else random.sample(files,n_m),
                    **kwargs,
                )
            )

        all_vectors_b = []
        for d, files in tqdm.tqdm(list(self.results_benign.items())):
            all_vectors_b.extend(
                vector_getter(
                    [preprocessor(f) for f in random.sample(files,n_b)]
                    if preprocessor is not None 
                    else random.sample(files,n_b),**kwargs,
                )
            )

        y_viz = ['Malware' for _ in all_vectors_m]+['Benign' for _ in all_vectors_b]
        ts = vizzer.fit_transform(np.array(all_vectors_m+all_vectors_b))
        # ts = TSNE(perplexity=10).fit_transform(np.array(all_vectors_m+all_vectors_b), y_viz)
        df = pd.DataFrame()
        df["y"] = y_viz
        df["comp-1"] = ts[:,0]
        df["comp-2"] = ts[:,1]

        plt.figure(figsize=figsize, facecolor='white')

        # sns.set_style("dark")
        g = sns.scatterplot(x="comp-1", y="comp-2", hue=df.y.tolist(),
                        palette=["#de1a24","#056517",],
                        data=df)
        g.set(title=title) 
