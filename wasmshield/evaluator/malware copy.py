from time import perf_counter
import matplotlib.pyplot as plt 
import matplotlib

from wasmshield.models.base_handler import BaseHandler
plt.style.use('fivethirtyeight')
matplotlib.rcParams["figure.facecolor"] = 'white'
matplotlib.rcParams["axes.facecolor"] = 'white'

import os
from collections import defaultdict
import itertools
import random
import tqdm
import sklearn.ensemble
import sklearn.linear_model
import sklearn.svm
import numpy as np
import torch
import tqdm
from wasmshield.training.trainer import TrainableModel, divide_chunks
import joblib
from sklearn.base import BaseEstimator
import wasmshield.utils
import wasmshield.preprocessing
import wasmshield.ennemies.minos
import wasmshield.ennemies.jabberwock
from sklearn.metrics import classification_report

import pandas as pd
import seaborn as sns
import random
import numpy as np
import wasmshield.utils
from umap.umap_ import UMAP


class MalwareEvaluator:
    def __init__(
        self,device,
    ):
        
        semantic_orig_dataset = 'datasets/wasim_dataset/WasmDataset/Cryptominer'
        files = list(os.walk(semantic_orig_dataset))[0][-1]
        files = [semantic_orig_dataset+'/'+file for file in files]

        #
        self.malware_filenames_test = joblib.load('evaluation_logs/malware_filenames_test')
        self.malware_filenames_train = joblib.load('evaluation_logs/malware_filenames_train') + files
        malware_filenames_train = self.malware_filenames_train
        self.benign_filenames_train = joblib.load('evaluation_logs/benign_filenames_train')
        benign_filenames_train = self.benign_filenames_train
        self.benign_filenames_test = joblib.load('evaluation_logs/benign_filenames_test')
        #
        self.y_train = joblib.load('evaluation_logs/malware_y_train_files_2')
        self.X_train_files = joblib.load('evaluation_logs/malware_X_train_files_2')
        #
        self.results_benign = joblib.load('evaluation_logs/results_benign')
        self.results_malware = joblib.load('evaluation_logs/results_malware')

        #
        self.malware_filenames_val_train = joblib.load('evaluation_logs/malware_filenames_val_train')
        self.malware_filenames_val_test = joblib.load('evaluation_logs/malware_filenames_val_test')
        self.benign_filenames_val_train = joblib.load('evaluation_logs/benign_filenames_val_train')
        self.benign_filenames_val_test = joblib.load('evaluation_logs/benign_filenames_val_test')
        #
        self.results_benign_val = joblib.load('evaluation_logs/results_benign_val')
        self.results_malware_val = joblib.load('evaluation_logs/results_malware_val')
        #
        self.y_train_val = joblib.load('evaluation_logs/malware_y_val_train_files_2')
        self.X_train_files_val = joblib.load('evaluation_logs/malware_X_val_train_files_2')

        self.device = device

        def zipper_for_eval(a:list,b:list):
            a,b = list(a), list(b)
            fill = a[-1] if (len(a) < len(b)) else b[-1]
            return list(itertools.zip_longest(a, b, fillvalue=fill))
        
        self.eval_pairs = zipper_for_eval(
            self.results_malware.keys(),
            self.results_benign.keys(),
        )

        self.llvm_base_path = "compiled_datasets/llvm_obf/authors"
    
        self.obfuscation_technique_mapper = {
            'bcfobf':"Bogus control flow",
            'cffobf':"Control flow flattening",
            'constenc':"Constants encryption",
            'funcwra':"Function wrapper",
            'indibran':"Indirect branches",
            'splitobf':"Basic block splitting",
            'strcry':"String encryption",
            'subobf':"Substitute instruction",
            'antialiasanalysis':"Anti-alias analysis", 
            'antitaintanalysis':"Anti-taint analysis", 
            'encodearithmetic':"Encode arithmetic", 
            'encodeliterals':"Encode literals", 
            'flatten':"Flattening", 
            'randomfuns':"Random functions", 
            'split':"Function splitting", 
            'virtualize':"Virtualization",
            'AddCustomSectionMutator':"Add custom section", 
            'AddFunctionMutator':"Add function", 
            "AddTypeMutator":"Add Type", 
            "CodemotionMutator":"Code motion", 
            "PeepholeMutator":"Peephole"
        }

        (
            self.obfuscated_X_test, 
            self.obfuscated_y_test, 
            self.obfuscated_name_test, 
            self.obfuscated_technique_test,
        ) = self.handle_obfuscated_files(
            obfuscated_benign_folders=[
                'lcs','needleman_wunsch','smith_waterman','seqtk','f1-race','pong','breakout','wgsim','wasm-asteroids','snake',
            ],
            obfuscated_malware_folders=[
                'cn-1', 'cn-2', 'cn-r', 'cn-half', 'cn-lite-1', 'cn-lite-2', 'cn-rwz', 'cn-pico-trtl',
            ],
            obfuscations=[
                ('wasm-mutate','-1', ['AddCustomSectionMutator', 'AddFunctionMutator', "AddTypeMutator", "CodemotionMutator", "PeepholeMutator"]),
                ('wasm-mutate','-2', [
                    f'iteration-{i}' 
                    for i in [100,200,300,400,500,600,700,800,900,1000]
                ]),
                ('tigress','', [
                    'encodearithmetic', 'randomfuns', 'split',
                    ]),
                ('llvm','',['bcfobf','cffobf','constenc','funcwra','indibran','splitobf','strcry','subobf']),
                ('unobfuscated','',['None']),
            ],
        )

        (
            self.obfuscated_X_train, 
            self.obfuscated_y_train, 
            self.obfuscated_name_train, 
            self.obfuscated_technique_train,
        ) = self.handle_obfuscated_files(
            obfuscated_benign_folders=[ 'tree', 'game-of-life', ],
            obfuscated_malware_folders=[ 'cn-0', 'cn-lite-0', ],
            obfuscations=[
                ('tigress','', ['antialiasanalysis', 'antitaintanalysis', 'encodeliterals', 'flatten', 'virtualize']),
                ('unobfuscated','',['None']),
                ('wasm-mutate','-1', ['AddCustomSectionMutator', 'AddFunctionMutator', "AddTypeMutator", "CodemotionMutator", "PeepholeMutator"]),
            ],
        )

        self.train_X = np.concatenate((
            np.array(self.X_train_files),
            np.array(self.obfuscated_X_train),
        ))
        self.train_y = np.concatenate((
            np.array(self.y_train),
            np.array(self.obfuscated_y_train),
        ))

        self.test_X = []
        self.test_y = []
        for mal_id, ben_id in (self.eval_pairs):
            ffm, ffb = self.results_malware[mal_id], self.results_benign[ben_id]
            y_test = [1 for _ in range(len(ffm))] + [0 for _ in range(len(ffb))] 
            self.test_X+=ffm+ffb
            self.test_y+=y_test
        self.test_X = np.array(self.test_X)
        self.test_y = np.array(self.test_y)

        try:
            self.minos_results = joblib.load('evaluation_logs/malware_minos_results')           
        except:
            self.minos_results = self.eval_malware_evolution(
                model_predict_func=wasmshield.ennemies.minos.minos_get_predictions, 
                model_names=['minos'],
            )
            joblib.dump(self.minos_results, 'evaluation_logs/malware_minos_results')
        
        try:
            self.jabberwock_results = joblib.load('evaluation_logs/malware_jabberwock_results')  
        except:
            
            print('Loading Vectors')
            jw_y_train = [1]*len(malware_filenames_train) + [0]*len(benign_filenames_train)
            jw_X_train = wasmshield.ennemies.jabberwock.get_vectors_jabberwock(malware_filenames_train+benign_filenames_train)

            jw_y_train=np.array(list(jw_y_train))
            jw_X_train=np.array(list(jw_X_train))
            p = np.arange(0, len(jw_X_train))
            np.random.shuffle(p)

            lr = sklearn.linear_model.LogisticRegression(class_weight='balanced', max_iter=1000, penalty='l1', solver='liblinear')
            lr.fit(jw_X_train[p], jw_y_train[p])

            svm = sklearn.svm.SVC(class_weight='balanced', max_iter=1000,)
            svm.fit(jw_X_train[p], jw_y_train[p])

            rf = sklearn.ensemble.RandomForestClassifier(class_weight='balanced', n_estimators=500)
            rf.fit(jw_X_train[p], jw_y_train[p])

            self.jabberwock_results = self.eval_malware_evolution(
                model_predict_func=self.jw_sklearn_predict_many_fun,
                sklearn_models=[lr,svm, rf], 
                model_names=[
                    'jabberwock_logistic_regression_l1',
                    'jabberwock_svm_rbf',
                    'jabberwock_rf_500',
                ],
            )

            joblib.dump(self.jabberwock_results, 'evaluation_logs/malware_jabberwock_results') 


    def get_obfuscated_df(self, model_name):
        return pd.DataFrame.from_dict({
            'Obfuscation': self.obfuscated_name_test,
            'Transformation': self.obfuscated_technique_test,
            'label': self.obfuscated_y_test,
            'model_name':[
                model_name for _ 
                in range(len(self.obfuscated_y_test))
            ],
            'indexes':list(range(len(self.obfuscated_y_test)))
        })

    def handle_obfuscated_files(
        self,
        obfuscated_malware_folders,
        obfuscated_benign_folders,
        obfuscations,
    ):
        
        obfuscated_y = []
        obfuscated_X = []
        obfuscated_name = []
        obfuscated_technique = []

        for folders, y_value in [(obfuscated_malware_folders,1), (obfuscated_benign_folders,0)]:
            for folder in folders:
                for obfuscation_name, obfuscation_split, obfuscation_techniques in obfuscations:
                    for obfuscation_technique in obfuscation_techniques:

                        if obfuscation_technique != 'None':
                            file_path = f"{self.llvm_base_path}/{folder}/{obfuscation_name}/{obfuscation_technique}/{folder}.wasm"
                        else:
                            file_path = f"{self.llvm_base_path}/{folder}/{obfuscation_name}/{folder}.wasm"

                        if not os.path.exists(file_path):
                            print(file_path)

                        obfuscated_name.append(
                            obfuscation_name+obfuscation_split
                        )
                        obfuscated_technique.append(
                            self.obfuscation_technique_mapper.get(
                                obfuscation_technique, 
                                obfuscation_technique
                            )
                        )
                        obfuscated_X.append(file_path)
                        obfuscated_y.append(y_value)

        return obfuscated_X, obfuscated_y, obfuscated_name, obfuscated_technique
    
    def sklearn_train_many_models(
        self, 
        X_train_files, 
        y_train,
        sklearn_models:list[BaseEstimator],
        handler:BaseHandler
    ):
        p = perf_counter()
        X_train = np.array(handler.get_vectors_from_files(X_train_files))
        y_train = np.array(self.y_train)
        p = perf_counter() - p
        
        perms = np.arange(0, len(X_train))
        np.random.shuffle(perms)
        X_train, y_train = X_train[perms], y_train[perms]

        trained_sklearn_models = []
        times = []
        for sklearn_model in sklearn_models:
            t = perf_counter()
            trained_sklearn_models.append(
                (sklearn_model.fit( X_train , y_train ))
            )
            t = perf_counter() - t
            times.append(t+p)
        return trained_sklearn_models, times
    
    def sklearn_eval_many_models(
        self, 
        sklearn_models, 
        sklearn_model_names,
        results_benign, 
        results_malware, 
        handler_name,
        handler:BaseHandler,
    ):
        return self.sklearn_eval_malware_evolution(
            sklearn_models=sklearn_models, 
            model_names=[
                handler_name+f'+{sklearn_model_name}'
                for sklearn_model_name in sklearn_model_names
            ],
            handler=handler,
            results_benign=results_benign,
            results_malware=results_malware,
        )
    
    def sklearn_predict_many_fun(
        self, 
        files, 
        sklearn_models, 
        handler:BaseHandler
    ):
        p = perf_counter()
        X_test = handler.get_vectors_from_files(files)
        p = perf_counter() - p
        for sklearn_model in sklearn_models:
            t = perf_counter()
            pred = sklearn_model.predict(X_test)
            yield (perf_counter()-t+p, pred)
    
    def sklearn_eval_malware_evolution(
        self, 
        model_names,
        y_preds,
    ):
        eval_dict = defaultdict()
        for model_name, (time,y_pred) in zip(model_names, y_preds):
            results_evolution_list = []
            for pred_evolution, (time,y_evolution) in zip(
                divide_chunks(y_pred, 48),
                divide_chunks(self.test_y, 48),
            ):
                results_evolution = classification_report(
                    y_evolution,
                    pred_evolution,
                    output_dict=True,
                )
                results_evolution['time'] = time
                results_evolution_list.append(results_evolution)
            overall_results = classification_report(
                self.test_y, y_pred, output_dict=True
            )
            eval_dict[model_name] = {
                'time':time,
                'results_evolution_list':results_evolution_list,
                'overall_results':overall_results,
            }

        return eval_dict
    
    def malware_results_plotter(
        self, 
        model_results, 
        figsize, 
        figsize2, 
        rounder=0, 
        legend_bbox_to_anchor=(0.5, -0.1), 
        ncol_legend=2, 
        y_step=0.05,
        show_concurrent=True,
    ):

        def myround(x, base=5):
            return base * round(x/base)
        
        if show_concurrent:
            model_results['minos'] = self.minos_results['minos']
            model_results['jabberwock_svm_rbf'] = self.jabberwock_results['jabberwock_svm_rbf']
            model_results['jabberwock_rf_500'] = self.jabberwock_results['jabberwock_rf_500']
            model_results['jabberwock_logistic_regression_l1'] = self.jabberwock_results['jabberwock_logistic_regression_l1']

        # x = list(self.results_malware.keys())
        # x = [round(x,-rounder) for x in self.results_malware.keys()]
        x = [myround(x,rounder) for x in self.results_malware.keys()]
        y_getters = lambda k : [
            (lambda result_dicts : [x[k]['precision'] for x in result_dicts] ,'Precision'),
            (lambda result_dicts : [x[k]['recall'] for x in result_dicts], 'Rappel'),
            (lambda result_dicts : [x[k]['f1-score'] for x in result_dicts], 'F1-Score'),
        ]

        for k, y_label in [('weighted avg', 'Overall'), ('1', 'Classe de Malware'), ('0', 'Classe Benign')]:
            plt.figure(figsize=figsize, facecolor='white')
            for (model_name, result_dicts) in (model_results.items()):
                for y_idx, (y_getter, y_type) in enumerate(y_getters(k)):
                    plt.subplot(1,len(y_getters(k)),y_idx+1)
                    y = np.array(y_getter(result_dicts))
                    g = sns.lineplot(x=x, y=y, label=model_name, marker='o',)
                    g.set_ylim(0, 1.02)
                    g.set_ylabel(y_type+f' ( {y_label} ) ')
                    g.set_yticks(np.arange(0, 1.02, y_step))
                    g.set_xlabel('Profondeur de Mutation')  
                    plt.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor,
                        fancybox=True, shadow=True, ncol=ncol_legend)
        
        plt.figure(figsize=figsize2, facecolor='white')
        for (model_name, result_dicts) in (model_results.items()):
            for y_idx, (y_label, (y_getter, y_type)) in enumerate([
                ('Overall', y_getters('weighted avg')[2],),
                ('Classe de Malware', y_getters('1')[1],),
            ]):
                plt.subplot(1,2,y_idx+1)
                y = np.array(y_getter(result_dicts))
                g = sns.lineplot(x=x, y=y, label=model_name, marker='o',)
                g.set_ylim(0, 1.02)
                g.set_yticks(np.arange(0, 1.02, y_step))
                g.set_ylabel(y_type+f' ( {y_label} ) ')
                g.set_xlabel('Profondeur de Mutation')  
                plt.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor, fancybox=True, shadow=True, ncol=ncol_legend)

    def malware_results_barplotter(self, model_results, figsize1, figsize2, depths, plot_heatmaps=False, palette=None, legend_bbox_to_anchor=(0.5, -0.1), ncol_legend=2):

        recs = []

        models = list(model_results.keys())

        if plot_heatmaps:

            cols = ['Column {}'.format(col) for col in models]
            rows = [f'M{self.eval_pairs[n][0]}_B{self.eval_pairs[n][1]}' for n in depths]
            fig, axes = plt.subplots(nrows=len(depths), ncols=len(models), figsize=figsize1, facecolor='white')

            for ax, col in zip(axes[0], cols):
                ax.set_title(col)
            for ax, row in zip(axes[:,0], rows):
                ax.set_ylabel(row, rotation=0, size='large')

            fig.tight_layout()

        for depth_idx, n in enumerate(depths):
            m = self.eval_pairs[n]
            d_name = f'M{m[0]}_B{m[1]}'
            models = list(model_results.items())
            for model_idx, (model_name, res_dict) in enumerate(models):
                recs.append(
                    {
                        'model_name' : model_name,
                        'f1-score' : res_dict[n]['weighted avg']['f1-score'],
                        'd_name' : d_name
                    }
                )
                cf_matrix = np.array(
                    [[res_dict[n]['0']['precision'], 1-res_dict[n]['0']['precision']],
                    [1-res_dict[n]['1']['precision'], res_dict[n]['1']['precision']]]
                )
                # ax = plt.subplot(len(depths), len(models), depth_idx*(len(models))+model_idx+1)
                # plt.title(f'{model_name} {d_nam<e}')
                if plot_heatmaps:
                    sns.heatmap(cf_matrix, annot=True, fmt='.2%', cmap='Blues', ax=axes[depth_idx][model_idx])

        plt.figure(figsize=figsize2, facecolor='white')
        ax = sns.barplot(pd.DataFrame.from_records(recs), x='d_name', y='f1-score', hue='model_name', palette=palette)
        # sns.move_legend(ax, "upper left", bbox_to_anchor=(1, 1))
        ax.legend(loc='upper center', bbox_to_anchor=legend_bbox_to_anchor,
          fancybox=True, shadow=True, ncol=ncol_legend)
        for i in ax.containers:
            ax.bar_label(i,fmt='%.4f')
        
    def malware_results_embedding_plotter(
            self,
            vector_getter,
            figsize,
            n_m,
            n_b,
            preprocessor=None,
            vizzer = UMAP(),
            title="Plot of Mawlare-Benign",
            **kwargs,
        ):

        if model:=kwargs.get('model'):
            wasmshield.utils.set_torch_model_to_train(model, False)

        all_vectors_m = []
        for d, files in tqdm.tqdm(list(self.results_malware.items())):
            all_vectors_m.extend(
                vector_getter(
                    [preprocessor(f) for f in random.sample(files,n_m)]
                    if preprocessor is not None 
                    else random.sample(files,n_m),
                    **kwargs,
                )
            )

        all_vectors_b = []
        for d, files in tqdm.tqdm(list(self.results_benign.items())):
            all_vectors_b.extend(
                vector_getter(
                    [preprocessor(f) for f in random.sample(files,n_b)]
                    if preprocessor is not None 
                    else random.sample(files,n_b),**kwargs,
                )
            )

        y_viz = ['Malware' for _ in all_vectors_m]+['Benign' for _ in all_vectors_b]
        ts = vizzer.fit_transform(np.array(all_vectors_m+all_vectors_b))
        # ts = TSNE(perplexity=10).fit_transform(np.array(all_vectors_m+all_vectors_b), y_viz)
        df = pd.DataFrame()
        df["y"] = y_viz
        df["comp-1"] = ts[:,0]
        df["comp-2"] = ts[:,1]

        plt.figure(figsize=figsize, facecolor='white')

        # sns.set_style("dark")
        g = sns.scatterplot(x="comp-1", y="comp-2", hue=df.y.tolist(),
                        palette=["#de1a24","#056517",],
                        data=df)
        g.set(title=title) 
